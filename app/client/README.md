# Proxy Client Implementation

## 概述

这是一个基于Java OkHttpClientExternal实现的Go语言代理客户端，完整实现了原有的功能，包括：

- WebSocket连接管理
- TCP/UDP代理功能
- XOR加密/解密
- 连接池管理
- 心跳检测和自动重连
- 数据分块传输（大于8KB的数据）

## 文件说明

1. **app/client/client.go** - 核心客户端实现，包含所有协议处理逻辑
2. **app/client/runner.go** - 客户端启动入口，参考Java main方法实现
3. **main/run.go** - 集成到Xray启动流程

## 功能特性

### 协议支持

客户端支持以下命令类型（与Java版本完全一致）：

- `0` - 新建TCP连接
- `1` - 数据转发
- `2` - 关闭TCP连接
- `3` - 连接成功通知
- `4` - 数据传输结束
- `5` - 心跳检测
- `6` - 读取短信（保留功能）
- `7` - UDP数据传输
- `8` - 关闭UDP连接
- `9` - 服务器推送指令

### 执行顺序

客户端严格按照以下顺序执行（与Java版本一致）：

1. **初始化阶段**
   - 创建单例实例
   - 设置XOR加密密钥（使用UID作为密钥）
   - 初始化连接池和管理器

2. **启动阶段**
   - 建立WebSocket连接到服务器
   - 启动心跳检测线程（每30秒）
   - 启动连接清理线程（每30秒）

3. **运行阶段**
   - 接收并处理服务器消息
   - 管理TCP/UDP连接
   - 自动清理不活跃连接（60秒超时）
   - 监控连接状态（每5秒输出一次）

4. **停止阶段**
   - 关闭所有TCP连接
   - 关闭所有UDP连接
   - 关闭WebSocket连接
   - 清理所有资源

## 配置说明

客户端可以通过环境变量配置：

```bash
# WebSocket服务器地址（默认：ws://127.0.0.1:9981/user/session）
export PROXY_SERVER_URL="ws://your-server:port/user/session"

# 用户ID（默认：ug-user9）
export PROXY_UID="your-uid"

# 国家代码（默认：th）
export PROXY_COUNTRY_CODE="cn"

# 移动国家代码和网络代码（默认：46000）
export PROXY_MCCMNC="46000"
```

## 使用方式

### 随Xray自动启动

客户端已集成到Xray的启动流程中，当启动Xray时会自动启动代理客户端：

```bash
./xray run -c config.json
```

客户端会在后台运行，并每5秒输出一次状态信息：

```
正常连接: true | TCP数量: 3 | UDP数量: 1
```

### 独立使用

如果需要独立使用代理客户端功能，可以在代码中调用：

```go
import "github.com/xtls/xray-core/app/client"

func main() {
    // 方式1：使用默认配置
    client.Run()
    
    // 方式2：自定义配置
    proxyClient := client.GetInstance(
        "ws://127.0.0.1:9981/user/session",  // serverURL
        "ug-user9",                           // uid
        "th",                                 // countryCode
        "46000",                              // mccmnc
        true,                                 // autoReconnect
    )
    proxyClient.Start()
}
```

## 协议细节

### 数据包格式

所有消息都遵循以下格式：

```
[4字节保留] [16字节SessionID] [1字节命令类型] [数据]
```

### TCP连接流程

1. **服务器发送新建连接命令（0）**
   ```
   [保留][SessionID][0][主机长度][主机名][端口]
   ```

2. **客户端建立连接并响应连接成功（3）**
   ```
   [保留][SessionID][3]
   ```

3. **双向数据转发（1）**
   - 服务器 → 客户端 → 目标服务器
   - 目标服务器 → 客户端 → 服务器
   - 数据使用XOR加密

4. **关闭连接（2或4）**
   ```
   [保留][SessionID][2/4]
   ```

### UDP数据流程

1. **服务器发送UDP数据（7）**
   ```
   [保留][SessionID][7][主机长度][主机名][端口][数据长度][加密数据]
   ```

2. **客户端转发并等待响应**

3. **客户端返回UDP响应（7）**
   ```
   [保留][SessionID][7][数据长度][加密数据]
   ```

### 数据分块

对于大于8KB的数据，会自动分块传输：

```
[保留][SessionID][1][分片标志=1][分片会话ID][分片总数][分片序号][数据]
```

## 关键实现细节

1. **XOR加密**：使用UID作为密钥进行循环XOR加密/解密

2. **连接管理**：使用sync.Map实现线程安全的连接池

3. **超时清理**：不活跃连接60秒后自动清理

4. **心跳检测**：每30秒发送一次心跳，检测连接状态

5. **自动重连**：连接断开后10秒自动重连

6. **单例模式**：确保整个应用只有一个客户端实例

## 与Java版本的差异

Go实现与Java版本在功能上完全一致，主要差异在于：

1. **并发模型**：
   - Java使用Netty的EventLoopGroup + 线程池
   - Go使用goroutine + sync.Map

2. **内存管理**：
   - Java使用Netty的ByteBuf
   - Go使用原生的[]byte和bytes.Buffer

3. **日志系统**：
   - Java使用自定义Logger
   - Go使用Xray的log包

4. **错误处理**：
   - Java使用try-catch
   - Go使用error返回值

但核心逻辑、协议格式、执行顺序完全相同。

## 故障排查

### 连接失败

1. 检查服务器地址是否正确
2. 确认服务器是否在运行
3. 检查网络连接和防火墙设置

### 数据传输异常

1. 检查UID是否正确（用于加密）
2. 确认协议版本是否匹配
3. 查看日志中的错误信息

### 性能问题

1. 检查不活跃连接数量
2. 调整清理间隔和超时时间
3. 监控内存和CPU使用情况

## 开发者注意事项

如需修改代码，请注意：

1. 保持协议格式与服务器端一致
2. 维护执行顺序与Java版本相同
3. 测试TCP和UDP功能
4. 验证大数据包的分块传输
5. 确保加密/解密逻辑正确

